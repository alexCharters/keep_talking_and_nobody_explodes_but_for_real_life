`timescale 1ns / 1ps

/*
 * Testbench for i2c_master
 */
module test_i2c_master;

// Parameters

// Inputs
reg clk = 0;
reg rst = 0;
reg [7:0] current_test = 0;

reg [6:0] cmd_address = 7'b1010010;
reg cmd_start = 1;
reg cmd_read = 0;
reg cmd_write = 0;
reg cmd_write_multiple = 1;
reg cmd_stop = 0;
reg cmd_valid = 1;
reg [7:0] data_in = 8'b11100111;
reg data_in_valid = 1;
reg data_in_last = 0;
reg data_out_ready = 0;
reg scl_i = 1;
reg sda_i = 1;
reg [15:0] prescale = 0;
reg stop_on_idle = 0;

// Outputs
wire cmd_ready;
wire data_in_ready;
wire [7:0] data_out;
wire data_out_valid;
wire data_out_last;
wire scl_o;
wire scl_t;
wire sda_o;
wire sda_t;
wire busy;
wire bus_control;
wire bus_active;
wire missed_ack;

initial begin
    // myhdl integration
    $from_myhdl(
        clk,
        rst,
        current_test,
        cmd_address,
        cmd_start,
        cmd_read,
        cmd_write,
        cmd_write_multiple,
        cmd_stop,
        cmd_valid,
        data_in,
        data_in_valid,
        data_in_last,
        data_out_ready,
        scl_i,
        sda_i,
        prescale,
        stop_on_idle
    );
    $to_myhdl(
        cmd_ready,
        data_in_ready,
        data_out,
        data_out_valid,
        data_out_last,
        scl_o,
        scl_t,
        sda_o,
        sda_t,
        busy,
        bus_control,
        bus_active,
        missed_ack
    );

    // dump file
    $dumpfile("test_i2c_master.lxt");
    $dumpvars(0, test_i2c_master);
end



I2C
UUT (
    .clk(clk),
    .rst(rst),
    .cmd_address(cmd_address),
    .cmd_start(cmd_start),
    .cmd_read(cmd_read),
    .cmd_write(cmd_write),
    .cmd_write_multiple(cmd_write_multiple),
    .cmd_stop(cmd_stop),
    .cmd_valid(cmd_valid),
    .cmd_ready(cmd_ready),
    .data_in(data_in),
    .data_in_valid(data_in_valid),
    .data_in_ready(data_in_ready),
    .data_in_last(data_in_last),
    .data_out(data_out),
    .data_out_valid(data_out_valid),
    .data_out_ready(data_out_ready),
    .data_out_last(data_out_last),
    .scl_i(scl_i),
    .scl_o(scl_o),
    .scl_t(scl_t),
    .sda_i(sda_i),
    .sda_o(sda_o),
    .sda_t(sda_t),
    .busy(busy),
    .bus_control(bus_control),
    .bus_active(bus_active),
    .missed_ack(missed_ack),
    .prescale(prescale),
    .stop_on_idle(stop_on_idle)
);

always begin
	#5 clk <= !clk;
end

always@(posedge data_in_ready) begin
	data_in = (data_in==8'b00101011)?8'b11100111:8'b00101011;
end

endmodule






//// Copyright (C) 2018  Intel Corporation. All rights reserved.
//// Your use of Intel Corporation's design tools, logic functions 
//// and other software and tools, and its AMPP partner logic 
//// functions, and any output files from any of the foregoing 
//// (including device programming or simulation files), and any 
//// associated documentation or information are expressly subject 
//// to the terms and conditions of the Intel Program License 
//// Subscription Agreement, the Intel Quartus Prime License Agreement,
//// the Intel FPGA IP License Agreement, or other applicable license
//// agreement, including, without limitation, that your use is for
//// the sole purpose of programming logic devices manufactured by
//// Intel and sold by Intel or its authorized distributors.  Please
//// refer to the applicable agreement for further details.
//
//// *****************************************************************************
//// This file contains a Verilog test bench template that is freely editable to  
//// suit user's needs .Comments are provided in each section to help the user    
//// fill out necessary details.                                                  
//// *****************************************************************************
//// Generated on "10/08/2019 11:36:13"
//                                                                                
//// Verilog Test Bench template for design : I2C
//// 
//// Simulation tool : ModelSim-Altera (Verilog)
//// 
//
//`timescale 1 ps/ 1 ps
//module I2C_vlg_tst();
//// constants                                           
//// general purpose registers
//reg eachvec;
//// test vector input registers
//wire treg_SDA;
//reg clk;
//reg [7:0] data;
//reg dataReady;
//reg [6:0] address;
//reg rw;
//// wires                                               
//wire SCL;
//wire SDA;
//wire [3:0] CS;
//// assign statements (if any)                          
//assign SDA = treg_SDA;
//I2C i1 (
//// port map - connection between master ports and signals/registers   
//	.SCL(SCL),
//	.SDA(SDA),
//	.clk(clk),
//	.address(address),
//	.rw(rw),
//	.data(data),
//	.dataReady(dataReady),
//	.CS(CS)
//);
//
//assign treg_SDA = !i1.direction?1'b0:1'bz;
//
//initial                                                
//begin                                                  
//clk <= 0;
//dataReady <= 0;
//address <= 7'b1010010;
//rw <= 1'b0;
//data <= 8'b11101000;
//                                           
//$display("Running testbench");
//
//#20
//
//dataReady <= 1;                      
//end      
//                                              
//always                                                 
//begin                                                  
//	#5 clk <= !clk;
//end    
//                                                
//endmodule

